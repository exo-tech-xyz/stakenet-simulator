// Add this field to RebalancingSimulator struct
pub struct RebalancingSimulator {
    // ... existing fields ...
    pub pending_deactivation: u64, // Add this new field to track available stake from deactivations
    // ... rest of existing fields ...
}

impl RebalancingSimulator {
    // Update the new() method to initialize pending_deactivation
    pub async fn new(
        db_connection: &Pool<Postgres>,
        steward_config: Config,
        simulation_start_epoch: u16,
        simulation_end_epoch: u16,
        steward_cycle_rate: u16,
        number_of_validator_delegations: usize,
        instant_unstake_cap_bps: u32,
        validator_historical_start_offset: u16,
    ) -> Result<Self, CliError> {
        // ... existing initialization code ...
        
        Ok(Self {
            steward_config,
            simulation_start_epoch,
            simulation_end_epoch,
            steward_cycle_rate,
            number_of_validator_delegations,
            instant_unstake_cap_bps,
            validator_stake_states,
            validator_scores: HashMap::new(),
            current_cycle_end: simulation_start_epoch
                .checked_add(steward_cycle_rate)
                .unwrap(),
            total_lamports_staked,
            rebalancing_cycles: Vec::new(),
            top_validators: Vec::new(),
            pending_deactivation: 0, // Initialize to 0
            histories,
            jito_cluster_history,
            entries_by_validator: Arc::new(entries_by_validator),
            epoch_map: manual_withdraw_deposit_stake_epoch_map,
        })
    }

    /// Updated set_validator_targets with gradual deactivation
    fn set_validator_targets(&mut self, new_validator_set: &HashSet<String>) {
        // Calculate total stake that can be deactivated in this cycle
        let max_deactivation_amount = 
            (self.total_lamports_staked as u128 * self.instant_unstake_cap_bps as u128 / 10000)
                .min(u64::MAX as u128) as u64;

        // Collect validators not in new set with their scores and stake
        let mut validators_to_deactivate: Vec<(String, f64, u64)> = Vec::new();
        
        for (vote_account, stake_state) in self.validator_stake_states.iter() {
            if !new_validator_set.contains(vote_account) && stake_state.total() > 0 {
                let score = self.validator_scores.get(vote_account).copied().unwrap_or(0.0);
                validators_to_deactivate.push((vote_account.clone(), score, stake_state.total()));
            }
        }

        // Sort by score (lowest first for deactivation priority)
        validators_to_deactivate.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap_or(std::cmp::Ordering::Equal));

        // Deactivate stake up to the cap, starting with lowest-scored validators
        let mut total_deactivated = 0u64;
        let mut actual_deactivated_stake = 0u64;

        for (vote_account, _score, total_stake) in validators_to_deactivate {
            if total_deactivated + total_stake <= max_deactivation_amount {
                // Deactivate entire validator
                if let Some(stake_state) = self.validator_stake_states.get_mut(&vote_account) {
                    stake_state.target = 0;
                    let active_to_deactivate = stake_state.active;
                    let activating_to_deactivate = stake_state.activating;
                    
                    stake_state.deactivating += active_to_deactivate + activating_to_deactivate;
                    stake_state.active = 0;
                    stake_state.activating = 0;
                    
                    actual_deactivated_stake += active_to_deactivate + activating_to_deactivate;
                    
                    info!(
                        "Deactivating entire validator {} ({:.3} SOL) - Score: {:.4}",
                        vote_account,
                        total_stake as f64 / LAMPORTS_PER_SOL as f64,
                        _score
                    );
                }
                total_deactivated += total_stake;
            } else if total_deactivated < max_deactivation_amount {
                // Partial deactivation
                let remaining_capacity = max_deactivation_amount - total_deactivated;
                if let Some(stake_state) = self.validator_stake_states.get_mut(&vote_account) {
                    let mut amount_to_deactivate = remaining_capacity;
                    
                    // First deactivate from activating stake
                    let activating_deactivation = std::cmp::min(amount_to_deactivate, stake_state.activating);
                    stake_state.activating -= activating_deactivation;
                    stake_state.deactivating += activating_deactivation;
                    amount_to_deactivate -= activating_deactivation;
                    
                    // Then from active stake if needed
                    if amount_to_deactivate > 0 && stake_state.active > 0 {
                        let active_deactivation = std::cmp::min(amount_to_deactivate, stake_state.active);
                        stake_state.active -= active_deactivation;
                        stake_state.deactivating += active_deactivation;
                        amount_to_deactivate -= active_deactivation;
                    }
                    
                    let total_deactivated_this_validator = remaining_capacity - amount_to_deactivate;
                    actual_deactivated_stake += total_deactivated_this_validator;
                    
                    // Update target proportionally
                    let remaining_stake = stake_state.total();
                    stake_state.target = remaining_stake;
                    
                    info!(
                        "Partially deactivating validator {} ({:.3} SOL of {:.3} SOL) - Score: {:.4}",
                        vote_account,
                        total_deactivated_this_validator as f64 / LAMPORTS_PER_SOL as f64,
                        total_stake as f64 / LAMPORTS_PER_SOL as f64,
                        _score
                    );
                }
                break; // We've hit the cap
            } else {
                break; // Already at cap
            }
        }

        // Set targets for remaining validators (those not being deactivated)
        for (vote_account, stake_state) in self.validator_stake_states.iter_mut() {
            if new_validator_set.contains(vote_account) {
                // These will get their targets set in redistribute_stakes
                continue;
            } else if stake_state.target > 0 {
                // This validator still has stake remaining after partial deactivation
                // Target is already set above
                continue;
            }
        }

        // Store the amount available for redistribution
        self.pending_deactivation = actual_deactivated_stake;
        
        info!(
            "Gradual migration: Deactivated {:.3} SOL ({:.2}% of total) from lowest-scored validators",
            actual_deactivated_stake as f64 / LAMPORTS_PER_SOL as f64,
            (actual_deactivated_stake as f64 / self.total_lamports_staked as f64) * 100.0
        );
    }

    /// Updated redistribute_stakes to prioritize high-scored validators
    fn redistribute_stakes(&mut self, target_total: u64) {
        // Sort top validators by score (highest first for priority)
        let mut sorted_validators = self.top_validators.clone();
        sorted_validators.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap_or(std::cmp::Ordering::Equal));

        // Calculate the ideal stake per validator based on total
        let stake_per_validator: u64 = target_total / sorted_validators.len() as u64;
        
        // Set desired targets for all selected validators
        self.validator_scores.clear();
        for validator in &sorted_validators {
            self.validator_scores.insert(validator.vote_account.clone(), validator.score);
            
            if let Some(stake_state) = self.validator_stake_states.get_mut(&validator.vote_account) {
                stake_state.desired_target = stake_per_validator;
            }
        }

        // Calculate how much stake we can actually allocate this cycle
        let available_for_redistribution = self.pending_deactivation;
        
        if available_for_redistribution == 0 {
            info!("No stake available for redistribution in this cycle");
            return;
        }

        // Distribute available stake prioritizing high-scored validators to reach their desired_target first
        let mut remaining_stake = available_for_redistribution;
        
        for validator in &sorted_validators {
            if remaining_stake == 0 {
                break;
            }
            
            let current_state = self.validator_stake_states
                .get(&validator.vote_account)
                .expect("Validator should exist in stake states");
                
            let current_total = current_state.total();
            let desired_target = current_state.desired_target;
            
            // Calculate how much this validator needs to reach desired target
            let needed_stake = if desired_target > current_total {
                desired_target - current_total
            } else {
                0
            };
            
            // Allocate what we can (either what's needed or what's available)
            let allocation = std::cmp::min(needed_stake, remaining_stake);
            
            if allocation > 0 {
                if let Some(stake_state) = self.validator_stake_states.get_mut(&validator.vote_account) {
                    stake_state.target = current_total + allocation;
                    stake_state.add_activating_stake(allocation);
                    remaining_stake -= allocation;
                    
                    info!(
                        "Allocating {:.3} SOL to validator {} (Score: {:.4}) - Progress: {:.1}% of desired target",
                        allocation as f64 / LAMPORTS_PER_SOL as f64,
                        validator.vote_account,
                        validator.score,
                        ((current_total + allocation) as f64 / desired_target as f64) * 100.0
                    );
                }
            } else {
                // Validator already at or above desired target
                if let Some(stake_state) = self.validator_stake_states.get_mut(&validator.vote_account) {
                    stake_state.target = current_total;
                }
            }
        }

        // Reset pending deactivation since we've distributed it
        self.pending_deactivation = 0;

        info!(
            "Redistributed {:.3} SOL to validators (target: {:.3} SOL each, remaining unfulfilled: {:.3} SOL)",
            (available_for_redistribution - remaining_stake) as f64 / LAMPORTS_PER_SOL as f64,
            stake_per_validator as f64 / LAMPORTS_PER_SOL as f64,
            remaining_stake as f64 / LAMPORTS_PER_SOL as f64
        );
    }
}